#ifndef WATTX_FCMP_FFI_H
#define WATTX_FCMP_FFI_H

/* This file is auto-generated by cbindgen. Do not edit manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Success
 */
#define FCMP_SUCCESS 0

/**
 * Invalid parameter (null pointer, wrong size, etc.)
 */
#define FCMP_ERROR_INVALID_PARAM -1

/**
 * Proof generation failed
 */
#define FCMP_ERROR_PROOF_GENERATION -2

/**
 * Proof verification failed
 */
#define FCMP_ERROR_PROOF_VERIFICATION -3

/**
 * Memory allocation failed
 */
#define FCMP_ERROR_MEMORY -4

/**
 * Invalid point on curve
 */
#define FCMP_ERROR_INVALID_POINT -5

/**
 * Invalid scalar
 */
#define FCMP_ERROR_INVALID_SCALAR -6

/**
 * Not initialized
 */
#define FCMP_ERROR_NOT_INITIALIZED -7

/**
 * Internal error
 */
#define FCMP_ERROR_INTERNAL -99

/**
 * Size of a scalar in bytes
 */
#define SCALAR_SIZE 32

/**
 * Size of a point in bytes (compressed)
 */
#define POINT_SIZE 32

/**
 * Size of an output tuple (O, I, C = 3 points)
 */
#define OUTPUT_TUPLE_SIZE (POINT_SIZE * 3)

/**
 * Elements per output in field representation
 */
#define ELEMENTS_PER_OUTPUT 6

/**
 * Single layer of a branch
 */
typedef struct FcmpBranchLayer {
    /**
     * Number of elements in this layer
     */
    uint32_t num_elements;
    /**
     * Pointer to elements (array of 32-byte scalars)
     */
    const uint8_t *elements;
} FcmpBranchLayer;

/**
 * Branch data for proof generation
 */
typedef struct FcmpBranch {
    /**
     * Leaf index in the tree
     */
    uint64_t leaf_index;
    /**
     * Number of layers
     */
    uint32_t num_layers;
    /**
     * Pointer to layer data (array of FcmpBranchLayer)
     */
    const struct FcmpBranchLayer *layers;
} FcmpBranch;

/**
 * Input tuple for verification
 */
typedef struct FcmpInput {
    /**
     * Re-randomized O point (x, y coordinates as scalars)
     */
    uint8_t o_tilde[64];
    /**
     * Re-randomized I point
     */
    uint8_t i_tilde[64];
    /**
     * R value for SA+L
     */
    uint8_t r[64];
    /**
     * Re-randomized C point
     */
    uint8_t c_tilde[64];
} FcmpInput;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the FCMP library with default parameters.
 *
 * Must be called before any other FCMP functions.
 * Thread-safe for multiple calls (idempotent).
 *
 * # Returns
 * - `FCMP_SUCCESS` on success
 * - `FCMP_ERROR_*` on failure
 */
int32_t fcmp_init(void);

/**
 * Clean up and free FCMP resources.
 *
 * After calling this, `fcmp_init()` must be called again before using other functions.
 */
void fcmp_cleanup(void);

/**
 * Check if FCMP is initialized.
 *
 * # Returns
 * - 1 if initialized
 * - 0 if not initialized
 */
int32_t fcmp_is_initialized(void);

/**
 * Generate a random scalar.
 *
 * # Safety
 * - `out` must point to at least 32 bytes of writable memory
 */
int32_t fcmp_scalar_random(uint8_t *out);

/**
 * Add two scalars: out = a + b (mod l)
 *
 * # Safety
 * - All pointers must point to at least 32 bytes
 * - `out` must be writable
 */
int32_t fcmp_scalar_add(uint8_t *out, const uint8_t *a, const uint8_t *b);

/**
 * Multiply two scalars: out = a * b (mod l)
 *
 * # Safety
 * - All pointers must point to at least 32 bytes
 * - `out` must be writable
 */
int32_t fcmp_scalar_mul(uint8_t *out, const uint8_t *a, const uint8_t *b);

/**
 * Multiply a point by a scalar: out = scalar * point
 *
 * # Safety
 * - All pointers must point to at least 32 bytes
 * - `out` must be writable
 */
int32_t fcmp_point_mul(uint8_t *out, const uint8_t *scalar, const uint8_t *point);

/**
 * Add two points: out = a + b
 *
 * # Safety
 * - All pointers must point to at least 32 bytes
 * - `out` must be writable
 */
int32_t fcmp_point_add(uint8_t *out, const uint8_t *a, const uint8_t *b);

/**
 * Get the Ed25519 base point (generator)
 *
 * # Safety
 * - `out` must point to at least 32 bytes of writable memory
 */
int32_t fcmp_point_basepoint(uint8_t *out);

/**
 * Check if a point is valid (on the curve)
 *
 * # Safety
 * - `point` must point to at least 32 bytes
 *
 * # Returns
 * - 1 if valid
 * - 0 if invalid
 */
int32_t fcmp_point_is_valid(const uint8_t *point);

/**
 * Hash data to a scalar using BLAKE2b
 *
 * # Safety
 * - `out` must point to at least 32 bytes of writable memory
 * - `data` must point to `data_len` bytes
 */
int32_t fcmp_hash_to_scalar(uint8_t *out, const uint8_t *data, uintptr_t data_len);

/**
 * Hash data to a point using BLAKE2b + Elligator-like mapping
 *
 * # Safety
 * - `out` must point to at least 32 bytes of writable memory
 * - `data` must point to `data_len` bytes
 */
int32_t fcmp_hash_to_point(uint8_t *out, const uint8_t *data, uintptr_t data_len);

/**
 * Create a Pedersen commitment: C = value * G + blinding * H
 *
 * # Safety
 * - `out` must point to at least 32 bytes of writable memory
 * - `value` and `blinding` must each point to 32 bytes
 */
int32_t fcmp_pedersen_commit(uint8_t *out, const uint8_t *value, const uint8_t *blinding);

/**
 * Estimate the proof size for given parameters
 *
 * # Arguments
 * - `num_inputs` - Number of inputs being proven
 * - `num_layers` - Number of tree layers
 *
 * # Returns
 * - Estimated proof size in bytes, or 0 on error
 */
uintptr_t fcmp_proof_size(uint32_t num_inputs, uint32_t num_layers);

/**
 * Generate an FCMP proof (placeholder implementation)
 *
 * # Safety
 * - All pointers must be valid
 * - `proof_out` must have at least `proof_max_len` bytes available
 * - `proof_len_out` must be writable
 *
 * # Returns
 * - `FCMP_SUCCESS` on success
 * - Error code on failure
 */
int32_t fcmp_prove(uint8_t *proof_out,
                   uintptr_t *proof_len_out,
                   uintptr_t proof_max_len,
                   const uint8_t *tree_root,
                   const uint8_t *output,
                   const struct FcmpBranch *branch);

/**
 * Verify an FCMP proof (placeholder implementation)
 *
 * # Safety
 * - All pointers must be valid
 *
 * # Returns
 * - `FCMP_SUCCESS` if proof is valid
 * - `FCMP_ERROR_PROOF_VERIFICATION` if proof is invalid
 * - Other error codes on failure
 */
int32_t fcmp_verify(const uint8_t *tree_root,
                    const struct FcmpInput *input,
                    const uint8_t *proof,
                    uintptr_t proof_len);

/**
 * Get the library version string
 *
 * # Returns
 * Pointer to a null-terminated version string
 */
const int8_t *fcmp_version(void);

/**
 * Get error message for an error code
 *
 * # Returns
 * Pointer to a null-terminated error string
 */
const int8_t *fcmp_error_string(int32_t code);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* WATTX_FCMP_FFI_H */
