// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./IVerifier.sol";

/**
 * @title MockVerifier
 * @notice Mock ZK verifier for testing - NEVER use in production
 * @dev Returns true for all proofs. Replace with real Groth16 verifier for mainnet.
 *
 * In production, this contract would be generated by snarkjs/circom from:
 * - withdraw.circom: Proves knowledge of commitment in Merkle tree
 */
contract MockVerifier is IWithdrawVerifier {

    bool public mockResult = true;

    /**
     * @notice Set mock verification result (for testing)
     */
    function setMockResult(bool _result) external {
        mockResult = _result;
    }

    /**
     * @notice Mock proof verification - always returns mockResult
     * @dev In production, this performs actual pairing checks for Groth16
     *
     * Expected public inputs for withdrawal:
     * [0] - Merkle root (proves commitment exists)
     * [1] - Nullifier hash (prevents double-spend)
     * [2] - Amount being withdrawn
     * [3] - Recipient address (encoded as uint256)
     */
    function verifyProof(
        uint256[8] calldata /*proof*/,
        uint256[4] calldata /*publicInputs*/
    ) external view override returns (bool valid) {
        return mockResult;
    }
}

/**
 * @title MockDepositVerifier
 * @notice Mock verifier for deposit commitments
 */
contract MockDepositVerifier is IDepositVerifier {

    bool public mockResult = true;

    function setMockResult(bool _result) external {
        mockResult = _result;
    }

    /**
     * @notice Mock deposit proof verification
     *
     * Expected public inputs for deposit:
     * [0] - Commitment hash
     * [1] - Encrypted amount
     * [2] - (unused)
     * [3] - (unused)
     */
    function verifyProof(
        uint256[8] calldata /*proof*/,
        uint256[4] calldata /*publicInputs*/
    ) external view override returns (bool valid) {
        return mockResult;
    }
}
